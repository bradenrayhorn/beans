package db

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// custom query - could not be generated by sqlc due to transfer_account.id and .name being treated as not-null

const getTransactionsForBudget = `-- name: GetTransactionsForBudget :many
SELECT
  transactions.id, transactions.account_id, transactions.payee_id, transactions.category_id, transactions.transfer_id, transactions.date, transactions.amount, transactions.notes, transactions.created_at,
  accounts.name as account_name,
  categories.name as category_name,
  payees.name as payee_name,
  accounts.off_budget as account_off_budget,
  transfer_account.id as transfer_account_id,
  transfer_account.name as transfer_account_name
FROM transactions
JOIN accounts
  ON accounts.id = transactions.account_id
  AND accounts.budget_id = $1
LEFT JOIN categories
  ON categories.id = transactions.category_id
LEFT JOIN payees
  ON payees.id = transactions.payee_id
LEFT JOIN transactions transfer
  ON transfer.id = transactions.transfer_id
LEFT JOIN accounts transfer_account
  ON transfer_account.id = transfer.account_id
WHERE (transactions.id = $2 OR NOT $3)
ORDER BY transactions.date desc
`

type GetTransactionsForBudgetRow struct {
	Transaction         Transaction
	AccountName         string
	CategoryName        pgtype.Text
	PayeeName           pgtype.Text
	AccountOffBudget    bool
	TransferAccountID   pgtype.Text
	TransferAccountName pgtype.Text
}

type GetTransactionWithRelationsParams struct {
	ID       string
	BudgetID string
}

func (q *Queries) GetTransactionsForBudget(ctx context.Context, budgetID string) ([]GetTransactionsForBudgetRow, error) {
	return q.getTransactionsForBudget(ctx, budgetID, "")
}

func (q *Queries) GetTransactionWithRelations(ctx context.Context, params GetTransactionWithRelationsParams) (GetTransactionsForBudgetRow, error) {
	res, err := q.getTransactionsForBudget(ctx, params.BudgetID, params.ID)
	if err != nil {
		return GetTransactionsForBudgetRow{}, err
	}
	if len(res) != 1 {
		return GetTransactionsForBudgetRow{}, pgx.ErrNoRows
	}

	return res[0], nil
}

func (q *Queries) getTransactionsForBudget(ctx context.Context, budgetID string, transactionID string) ([]GetTransactionsForBudgetRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsForBudget, budgetID, transactionID, len(transactionID) > 0)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsForBudgetRow
	for rows.Next() {
		var i GetTransactionsForBudgetRow
		if err := rows.Scan(
			&i.Transaction.ID,
			&i.Transaction.AccountID,
			&i.Transaction.PayeeID,
			&i.Transaction.CategoryID,
			&i.Transaction.TransferID,
			&i.Transaction.Date,
			&i.Transaction.Amount,
			&i.Transaction.Notes,
			&i.Transaction.CreatedAt,
			&i.AccountName,
			&i.CategoryName,
			&i.PayeeName,
			&i.AccountOffBudget,
			&i.TransferAccountID,
			&i.TransferAccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
